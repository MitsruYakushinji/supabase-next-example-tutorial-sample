-- Custom types
CREATE TYPE public.app_permission AS ENUM ('projects.create', 'projects.delete', 'components.delete', 'pages.delete');
CREATE TYPE public.app_role AS ENUM ('admin', 'moderator');

-- USERS
CREATE TABLE public.users (
  id          UUID NOT NULL PRIMARY KEY, -- UUID from auth.users
  username    TEXT
);
COMMENT ON TABLE public.users IS 'Profile data for each user.';
COMMENT ON COLUMN public.users.id IS 'References the internal Supabase Auth user.';

-- USER ROLES
CREATE TABLE public.user_roles (
  id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id   UUID REFERENCES public.users ON DELETE CASCADE NOT NULL,
  role      app_role NOT NULL,
  UNIQUE (user_id, role)
);
COMMENT ON TABLE public.user_roles IS 'Application roles for each user.';

-- ROLE PERMISSIONS
CREATE TABLE public.role_permissions (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role         app_role NOT NULL,
  permission   app_permission NOT NULL,
  UNIQUE (role, permission)
);
COMMENT ON TABLE public.role_permissions IS 'Application permissions for each role.';

-- PROJECTS
CREATE TABLE public.projects (
  id            UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  inserted_at   TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  slug          TEXT NOT NULL UNIQUE,
  created_by    UUID REFERENCES public.users NOT NULL
);
COMMENT ON TABLE public.projects IS 'Projects.';

-- authorize with role-based access control (RBAC)
CREATE FUNCTION public.authorize(
  requested_permission app_permission,
  user_id UUID
)
RETURNS BOOLEAN AS
$$
  DECLARE
    bind_permissions INT;
  BEGIN
    SELECT
      COUNT(*)
    FROM public.role_permissions
    INNER JOIN public.user_roles ON role_permissions.role = user_roles.role
    WHERE
      role_permissions.permission = authorize.requested_permission AND
      user_roles.user_id = authorize.user_id
    INTO bind_permissions;

    RETURN bind_permissions > 0;
  END;
$$
LANGUAGE plpgsql SECURITY DEFINER;

-- Secure the tables
ALTER TABLE public.users
  ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles
  ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions
  ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.projects
  ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow logged-in read access" ON public.users
  FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow individual insert access" ON public.users
  FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Allow individual update access" ON public.users
  FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Allow logged-in read access" ON public.projects
  FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow individual insert access" ON public.projects
  FOR INSERT WITH CHECK (auth.uid() = created_by);
CREATE POLICY "Allow individual delete access" ON public.projects
  FOR DELETE USING (auth.uid() = created_by);
CREATE POLICY "Allow authorized delete access" ON public.projects
  FOR DELETE USING (authorize('projects.delete', auth.uid()));
CREATE POLICY "Allow individual read access" ON public.user_roles
  FOR SELECT USING (auth.uid() = user_id);

-- Send "previous data" on change
ALTER TABLE public.users
  REPLICA IDENTITY FULL;
ALTER TABLE public.projects
  REPLICA IDENTITY FULL;

-- inserts a row into public.users and assigns roles
CREATE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS
$$
  DECLARE is_admin BOOLEAN;
  BEGIN
    INSERT INTO public.users (id, username)
    VALUES (new.id, new.email);

    SELECT COUNT(*) = 1 FROM auth.users INTO is_admin;

    IF POSITION('@fox-hound' IN new.email) > 0 THEN
      INSERT INTO public.user_roles (user_id, role) VALUES (new.id, 'admin');
    END IF;

    RETURN new;
  END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- trigger the function every time a user is created
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

/**
 * REALTIME SUBSCRIPTIONS
 * Only allow realtime listening on public tables.
 */

BEGIN;
  -- remove the realtime publication
  DROP PUBLICATION IF EXISTS supabase_realtime;

  -- re-create the publication but don't enable it for any tables
  CREATE PUBLICATION supabase_realtime;
COMMIT;

-- add tables to the publication
ALTER PUBLICATION supabase_realtime ADD TABLE public.projects;
ALTER PUBLICATION supabase_realtime ADD TABLE public.users;

-- CONSTANTS DATA
INSERT INTO public.role_permissions (role, permission)
VALUES
    ('admin', 'projects.create'),
    ('admin', 'projects.delete');
